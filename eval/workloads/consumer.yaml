apiVersion: v1
kind: Service
metadata:
  name: consumer
spec:
  clusterIP: None
  selector:
    app: consumer
  ports:
  - port: 8080
    name: http
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: consumer
  labels:
    app: consumer
spec:
  serviceName: consumer
  replicas: 1
  selector:
    matchLabels:
      app: consumer
  template:
    metadata:
      labels:
        app: consumer
    spec:
      containers:
      - name: consumer
        image: python:3.11-slim
        command: ["/bin/bash", "-c"]
        args:
        - |
          pip install -q pika
          cat > /tmp/consumer.py << 'PYEOF'
          import pika, time, json, os, socket, threading
          from http.server import HTTPServer, BaseHTTPRequestHandler

          delay_ms = int(os.environ.get('PROCESSING_DELAY_MS', '50'))
          broker = os.environ.get('RABBITMQ_URL', 'amqp://guest:guest@rabbitmq.rabbitmq.svc.cluster.local:5672/')
          primary_queue = os.environ.get('QUEUE_NAME', 'app.events')

          # In-memory state (this is what CRIU preserves)
          state = {"processed": 0, "last_seq": -1}
          # MS2M replay state
          replay_state = {"active": False, "queue": None}

          class Handler(BaseHTTPRequestHandler):
              def do_GET(self):
                  self.send_response(200)
                  self.send_header('Content-Type', 'application/json')
                  self.end_headers()
                  self.wfile.write(json.dumps(state).encode())
              def log_message(self, *a): pass

          # Health endpoint in background
          srv = HTTPServer(('', 8080), Handler)
          threading.Thread(target=srv.serve_forever, daemon=True).start()

          def check_control_messages(ch, ctrl_queue):
              """Drain pending control messages from the control queue."""
              while True:
                  method, props, body = ch.basic_get(queue=ctrl_queue, auto_ack=True)
                  if method is None:
                      break
                  try:
                      msg = json.loads(body)
                      msg_type = msg.get('type', '')
                      if msg_type == 'START_REPLAY':
                          replay_state['active'] = True
                          replay_state['queue'] = msg.get('payload', {}).get('queue')
                          print(f"MS2M: START_REPLAY received, switching to {replay_state['queue']}", flush=True)
                      elif msg_type == 'END_REPLAY':
                          replay_state['active'] = False
                          replay_state['queue'] = None
                          print(f"MS2M: END_REPLAY received, switching back to {primary_queue}", flush=True)
                  except Exception as e:
                      print(f"MS2M: error parsing control message: {e}", flush=True)

          def run():
              while True:
                  try:
                      # Read hostname from /etc/hostname (bind-mounted by CRI-O)
                      # instead of socket.gethostname() which returns the CRIU-
                      # restored UTS hostname after checkpoint/restore.
                      try:
                          hostname = open('/etc/hostname').read().strip()
                      except Exception:
                          hostname = socket.gethostname()
                      ctrl_queue = f'ms2m.control.{hostname}'

                      conn = pika.BlockingConnection(pika.URLParameters(broker))
                      ch = conn.channel()

                      # Declare and check control queue for pending messages
                      ch.queue_declare(queue=ctrl_queue, durable=True)
                      check_control_messages(ch, ctrl_queue)

                      # Determine which queue to consume from
                      consume_queue = replay_state['queue'] if replay_state['active'] else primary_queue
                      ch.queue_declare(queue=consume_queue, durable=True)
                      ch.basic_qos(prefetch_count=1)

                      print(f"Consuming from {consume_queue}, delay={delay_ms}ms, replay_active={replay_state['active']}", flush=True)

                      def callback(ch, method, properties, body):
                          msg = json.loads(body)
                          time.sleep(delay_ms / 1000.0)
                          state["processed"] += 1
                          state["last_seq"] = msg.get("seq", -1)
                          if state["processed"] % 100 == 0:
                              print(f"Processed {state['processed']} messages, last_seq={state['last_seq']}", flush=True)
                          ch.basic_ack(delivery_tag=method.delivery_tag)

                      consumer_tag = ch.basic_consume(queue=consume_queue, on_message_callback=callback)

                      # Poll-based loop: process messages and periodically check control queue
                      while True:
                          conn.process_data_events(time_limit=1)

                          # Check for control messages
                          old_active = replay_state['active']
                          old_queue = replay_state.get('queue')
                          check_control_messages(ch, ctrl_queue)

                          # If replay state changed, switch queues
                          if replay_state['active'] != old_active or replay_state.get('queue') != old_queue:
                              ch.basic_cancel(consumer_tag)
                              new_queue = replay_state['queue'] if replay_state['active'] else primary_queue
                              ch.queue_declare(queue=new_queue, durable=True)
                              consumer_tag = ch.basic_consume(queue=new_queue, on_message_callback=callback)
                              print(f"Switched to consuming from {new_queue}", flush=True)

                  except pika.exceptions.AMQPConnectionError as e:
                      print(f"AMQP connection error: {e}, reconnecting in 3s...", flush=True)
                      time.sleep(3)
                  except pika.exceptions.AMQPChannelError as e:
                      print(f"AMQP channel error: {e}, reconnecting in 3s...", flush=True)
                      time.sleep(3)
                  except Exception as e:
                      print(f"Unexpected error: {e}, reconnecting in 3s...", flush=True)
                      time.sleep(3)

          run()
          PYEOF
          exec python3 /tmp/consumer.py
        env:
        - name: PROCESSING_DELAY_MS
          value: "10"
        - name: RABBITMQ_URL
          value: "amqp://guest:guest@rabbitmq.rabbitmq.svc.cluster.local:5672/"
        - name: QUEUE_NAME
          value: "app.events"
        ports:
        - containerPort: 8080
          name: http
        readinessProbe:
          httpGet:
            path: /
            port: 8080
          initialDelaySeconds: 1
          periodSeconds: 1
          failureThreshold: 3
